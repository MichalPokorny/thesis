\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[czech]{babel}

\begin{document}

\title{Efektivní implementace slovníků v RAM}
\author{Michael Pokorný}

\def\O{\mathcal{O}}
\def\Cpp{C++}

\maketitle
\tableofcontents

\section{Úvod}
Slovník patří mezi nejvíce používané datové struktury.
Jejich účel je spravovat konečnou množinu dvojic $\{(k_i,v_i)\}$,
kde $k_i$ se označují jako \textit{klíče} a $v_i$ se označují
jako \textit{hodnoty}. Klíče a hodnoty jsou prvky \textit{univerza
klíčů} $U_K$, resp. \textit{univerza hodnot} $U_V$. Klíče, respektive
hodnoty uložené ve slovníku označíme jako $K, V$. Počet dvojic uložených
ve slovníku si označme jako $N$.

Žádný klíč se nesmí ve slovníku opakovat, proto slovníky reprezentují
funkce z $K$ do $V$.

Typické rozhraní slovníku tvoří následující funkce:
\begin{itemize}
\item \textsc{Find($k$)}
	nalezne k danému klíči $k$ příslušnou hodnotu $v$, nebo oznámí,
	že žádná taková hodnota neexistuje.

\item \textsc{Insert($k$,$v$)}
	vloží do slovníku dvojici $(k,v)$.

\item \textsc{Delete($k$)}
	ze slovníku odstraní dvojici s klíčem $k$, nebo oznámí,
	že žádná taková dvojice neexistuje.
\end{itemize}

TODO priklady pouziti slovniku

\subsection{Rozšíření slovníku}
Je-li definované uspořádání nad univerzem klíčů, pro některá použití
je užitečné rozšířit slovník o následující funkce:
\begin{itemize}
\item \textsc{Successor($k$)}
	vrátí nejmenší klíč větší než $k$, který je uložený ve slovníku.
\item \textsc{Predecessor($k$)}
	naopak vrátí nejvyšší uložený klíč menší než $k$.
\end{itemize}

TODO pro ktera pouziti se to hodi?

Slovníky mohou k jednomu klíči ukládat více hodnot (například v případě
standartní knihovny \Cpp šablona \texttt{std::multimap}). V takovém případě
\textsc{Find} umožňuje iterovat nad všemi hodnotami příslušejícími ke klíči a
\textsc{Delete} maže pouze jeden pár $(k,v)$.

\subsection{Triviální implementace}
\subsubsection{Pole párů klíč-hodnota}
TODO obrazek

Jednoduchý slovník lze implementovat jako prosté pole párů $(k_i,v_i)$,
avšak taková implementace je velmi pomalá:
\begin{itemize}
\item \textsc{Find}
	má asymptotickou složitost $\O(N)$.
\item \textsc{Insert}
	může být implementovaný s asymptotickou složitostí $\O(1)$
	pomocí udržování odkazu na konec slovníku.
\item \textsc{Delete}
	musí mít složitost $\O(N)$, aby v poli nevznikaly díry --
	všechny dvojice za smazaným párem musí být posunuty doleva.
\end{itemize}

TODO a co spojovy seznam? unrolled linked list?

\subsubsection{Přímá adresace}
Je-li množina $U_K$ dostatečně malá, lze klíče interpretovat jako
adresy v paměti. Na adrese $k_i$ pak uložíme buď hodnotu $v_i$, nebo
značku, že žádná taková hodnota ještě neexistuje.

TODO obrazek

\textsc{Find}, \textsc{Insert} i \textsc{Delete} jsou pak operace s konstantní
časovou složitostí -- stačí jenom provést jednu dereferenci.
Tento přístup je bohužel málokdy praktický, protože univerzum klíčů $U_K$
je příliš velké na to, aby bylo možné alokovat $\O(|U_K|)$ místa.

\section{Hashování}
Hashování spočívá v \uv{kompresi} množiny $U_K$ do menší množiny $H$ pomocí
takzvané \textit{hashovací funkce} $h: U_K\rightarrow H$.
$H$ je přitom zvolena dost malá na to, aby bylo možné prvky $H$ indexovat
paměť. Protože $H$ je menší než $U_K$, nutně musí být přípustné, aby
více klíčů mělo stejnou hodnotu $h(k)$ (\textit{hash}).

Slovníky použivající hashování se jmenují \textit{hashovací tabulky}.
Informaci o tom, jaká hodnota přísluší klíči $k$, uložíme
v tabulce na indexu $h(k)$ jako pár $(k,v)$.

Operaci \textsc{Find} provedeme tak, že hashovací funkcí \textit{zahashujeme}
hledaný klíč a podíváme se, jaké páry jsou v hashovací tabulce uloženy
na výsledném indexu. Pokud některý z nich má hledaný klíč, vrátíme v něm
uloženou hodnotu.

Má-li více uložených dvojic stejný hash klíče, nastane takzvaná \textit{kolize}.
Existuje několik přístupů k řešení kolizí. Každý z nich přináší další
časovou náročnost, proto je žádoucí, aby funkce $h$ vracela prvky $H$
v přibližně uniformní distribuci.

Nastává-li příliš mnoho kolizí nebo je-li hashovací tabulka příliš málo
obsazená (a tedy paměťově neefektivní), můžeme provést \textit{přehashování} --
zvolíme novou množinu $H'$ a v čase $O(|H'|+|H|+N)$ vytvoříme novou hashovací
tabulku.

Přehashování udržuje zaplněnost hashovací tabulky uvnitř zvolených mezí
(například 50\%-90\%), které zaručují, že se neplýtvá pamětí a že kolize
nezpomalují vyhledávání.
Nová velikost hashovací tabulky se obvykle volí jako poměrný násobek předchozí
velikosti -- například $1/2\times$ při zmenšení a $2\times$ při zvětšení.

Díky tomuto exponenciálnímu zvětšování a zmenšování můžeme po každém vložení
nebo vymazání prvku zkontrolovat zaplněnost tabulky a případně přehashovat bez
podstatných důsledků v časové složitosti. Složitost přehashování lze totiž
amortizovat jako $\O(1)$ v okamžiku přidání prvku do tabulky.
TODO ukazat

\subsection{Kolizní seznam}
Každý index v hashovací tabulce obsahuje spojový seznam všech dvojic, jejichž
klíč má daný hash. Operace \textsc{Find}, \textsc{Delete} a \textsc{Insert}
tento seznam celý projdou. Problém tohoto přístupu spočívá především v
\textit{indirekci} - prvky spojových seznamů obsahují odkazy
na následující prvky, které musí být dereferencovány. Dereference
je pomalá operace. TODO

\subsection{Dvojité hashování}
\subsection{Otevřená adresace}
\subsection{Kukaččí hashování (\textit{cuckoo hashing})}

\section{Vyhledávací stromy}

\end{document}
